import json
import logging
from datetime import datetime
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
import base64

class SandboxReporter:
    def __init__(self, config):
        self.config = config
        template_dir = Path(__file__).parent.parent / 'templates'
        self.template_env = Environment(
            loader=FileSystemLoader(template_dir)
        )

    def _sanitize_for_json(self, data):
        """Convert bytes and other non-serializable types to strings"""
        if isinstance(data, bytes):
            try:
                return data.decode('utf-8')
            except UnicodeDecodeError:
                return base64.b64encode(data).decode('utf-8')
        elif isinstance(data, dict):
            return {key: self._sanitize_for_json(value) for key, value in data.items()}
        elif isinstance(data, list):
            return [self._sanitize_for_json(item) for item in data]
        elif isinstance(data, (int, float, str, bool, type(None))):
            return data
        else:
            return str(data)

    async def generate_report(self, analysis_results, sample_info):
        """Generates a complete report"""
        # Sanitize data for JSON serialization
        sanitized_results = self._sanitize_for_json(analysis_results)
        sanitized_info = self._sanitize_for_json(sample_info)
        
        report_data = {
            'timestamp': datetime.now().isoformat(),
            'sample': sanitized_info,
            'analysis': sanitized_results,
            'summary': self._generate_summary(sanitized_results),
            'risk_score': self._calculate_risk_score(sanitized_results)
        }

        try:
            # Report generation
            json_path = self._save_json_report(report_data)
            html_content = self._generate_html_report(report_data)
            html_path = self._save_html_report(html_content)

            return {
                'json_path': str(json_path),
                'html_path': str(html_path),
                'risk_score': report_data['risk_score']
            }
        except Exception as e:
            logging.error(f"Error generating report: {e}")
            raise

    def _generate_html_report(self, report_data):
        """Generate HTML report"""
        try:
            template = self.template_env.get_template('reports/report.html')
            return template.render(
                report=report_data,
                generated_at=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            )
        except Exception as e:
            logging.error(f"Error HTML template: {e}")
            raise

    def _calculate_risk_score(self, analysis_results):
        """Calculate risk score based on analysis"""
        score = 0
        static = analysis_results.get('static_analysis', {})
        dynamic = analysis_results.get('dynamic_analysis', {})
        
        # EICAR Check
        strings = static.get('strings', {}).get('ascii', [])
        if any('EICAR-STANDARD-ANTIVIRUS-TEST-FILE' in s for s in strings):
            return 85  # High score for EICAR
        
        # File type check
        file_type = static.get('file_type', '').lower()
        if 'executable' in file_type or file_type.endswith(('exe', 'dll', 'sys')):
            score += 20
        
        # Analyse statique
        if static.get('yara_matches'):
            score += len(static['yara_matches']) * 15
        
        # Analyse dynamique
        if dynamic.get('network_activity'):
            score += len(dynamic['network_activity']) * 10
        
        if dynamic.get('registry_changes'):
            score += len(dynamic['registry_changes']) * 5
        
        # Processus suspects
        suspicious_processes = ['cmd.exe', 'powershell.exe', 'rundll32.exe']
        processes = dynamic.get('processes', [])
        if any(proc in str(processes) for proc in suspicious_processes):
            score += 25
        
        # VirusTotal
        vt_results = static.get('vt_results', {})
        if vt_results.get('positives', 0) > 0:
            score += min(vt_results['positives'] * 5, 40)
        
        return min(score, 100)

    def _save_json_report(self, report):
        """Sauvegarde le rapport JSON"""
        reports_dir = Path('reports')
        reports_dir.mkdir(exist_ok=True)
        
        report_path = reports_dir / f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=4, ensure_ascii=False)
        return report_path

    def _save_html_report(self, html_content):
        """Saving HTML Report"""
        reports_dir = Path('reports')
        reports_dir.mkdir(exist_ok=True)
        
        report_path = reports_dir / f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        return report_path

    def _generate_summary(self, analysis_results):
        """Generate detailed summary of the report"""
        static_analysis = analysis_results.get('static_analysis', {})
        dynamic_analysis = analysis_results.get('dynamic_analysis', {})
        
        return {
            'static_analysis': {
                'file_type': static_analysis.get('file_type', 'unknown'),
                'hashes': static_analysis.get('hashes', {}),
                'yara_matches': len(static_analysis.get('yara_matches', []))
            },
            'dynamic_analysis': {
                'processes_created': len(dynamic_analysis.get('processes', [])),
                'network_connections': len(dynamic_analysis.get('network_activity', [])),
                'file_operations': len(dynamic_analysis.get('file_operations', []))
            },
            'risk_level': self._determine_risk_level(analysis_results)
        }

    def _determine_risk_level(self, results):
        """Determine average score of report"""
        score = self._calculate_risk_score(results)
        if score >= 75:
            return 'high'
        elif score >= 40:
            return 'medium'
        return 'low'